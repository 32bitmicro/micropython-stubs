from _typeshed import Incomplete
from collections.abc import Generator

type_gen: Incomplete
DEBUG: int
log: Incomplete

def set_debug(val) -> None: ...

class CancelledError(Exception): ...
class TimeoutError(CancelledError): ...

class EventLoop:
    runq: Incomplete
    waitq: Incomplete
    cur_task: Incomplete
    def __init__(self, runq_len: int = ..., waitq_len: int = ...) -> None: ...
    def time(self): ...
    def create_task(self, coro) -> None: ...
    def call_soon(self, callback, *args) -> None: ...
    def call_later(self, delay, callback, *args) -> None: ...
    def call_later_ms(self, delay, callback, *args): ...
    def call_at_(self, time, callback, args=...) -> None: ...
    def wait(self, delay) -> None: ...
    def run_forever(self): ...
    def run_until_complete(self, coro) -> None: ...
    def stop(self) -> Generator[Incomplete, None, Incomplete]: ...
    def close(self) -> None: ...

class SysCall:
    args: Incomplete
    def __init__(self, *args) -> None: ...
    def handle(self) -> None: ...

class SysCall1(SysCall):
    arg: Incomplete
    def __init__(self, arg) -> None: ...

class StopLoop(SysCall1): ...
class IORead(SysCall1): ...
class IOWrite(SysCall1): ...
class IOReadDone(SysCall1): ...
class IOWriteDone(SysCall1): ...

_event_loop: Incomplete
_event_loop_class = EventLoop

def get_event_loop(runq_len: int = ..., waitq_len: int = ...): ...
def sleep(secs) -> Generator[Incomplete, None, None]: ...

class SleepMs(SysCall1):
    v: Incomplete
    arg: Incomplete
    def __init__(self) -> None: ...
    def __call__(self, arg): ...
    def __iter__(self): ...
    def __next__(self): ...

_stop_iter: Incomplete
sleep_ms: Incomplete

def cancel(coro) -> None: ...

class TimeoutObj:
    coro: Incomplete
    def __init__(self, coro) -> None: ...

def wait_for_ms(coro, timeout): ...
def wait_for(coro, timeout): ...
def coroutine(f): ...
def ensure_future(coro, loop=...): ...
def Task(coro, loop=...) -> None: ...
